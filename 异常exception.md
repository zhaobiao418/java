### 异常

```
异常就是再运行的时候发生不正常的情况,这里的运行(jvm底层编译+运行出现不正常的情况)
而我们怎么才能知道程序运行的时候有错误异常,java用类的形式对不正常的情况进行了描述,而描述这些运行不正常的类就称为异常类
异常也是通过java的面向对象的思想,把这些不正常的问题封装成了对象,用异常类对其进行描述,
不同的问题用不同的类去具体的描述,比如 : 脚标越界,空指针异常,所以定义了一个异常根类:Throwable:抛出异常
java因为i不同的错误要用不同的类:就是throwable下的子类,一般分为2中error(不可处理)和exception(可以处理)
```

`Error : 是由jvm抛出的严重性问题,一般不针对处理,直接修改程序`

`Exception: 逻辑业务发生错误`

##### 父类Throwable的方法 :

```
getMessage() : 获取异常信息,返回字符串
toString(): 获取异常类名和异常信息,返回字符串
printStackTrace() : 获取异常类名和异常信息,以及异常出现再程序的位置,返回值void
printStackTrace(PrintStream s): 通常该方法将异常内容报存再日志中,一边查阅
```

##### 自定义异常

自定义出现的问题称为自定义异常

`例如 : 脚标为负数,越界的情况下,我们封装成对象,要继承异常体系,(如果不继承的话,报错还是照着异常体系来报错,继承了异常体系对象,我们重写覆盖了报错的方法函数,就按照我们自定义的异常信息抛出来,被俩个关键字操作:throws,throw)`

如果让一个类成为异常类,必须要继承异常体系,因为只有异常体系的子类才由资格具备可抛性,被2个关键字操作

因为正是通过throw关键字标识将自定义异常抛出,,让调用者去处理,功能方法内部出现不能继续运行的情况,需要跳转时,就用throw把异常对象抛出

##### throws和throw的区别 :

```
thorws用于标识函数暴露出的异常类,并且可以抛出多个,用逗号分隔. throw用于抛出异常对象
throws用在函数上,后面跟上(咱们自定义的)异常类名.throw用在函数内,后面跟异常对象
```

##### 异常的分类 :

`编译时被检测异常 : 只要是Exception和其子类都是编译时出现情况,问题出现由针对性的处理,(除了特性子类RuntimeException体系,再编译的时候出现情况,这个类的体系不针对处理)`

`编译时不检测异常(这里的个人理解为:编译不检测异常,假如有异常的话也不会处理编译直接让通过,在运行时抛出发生的异常强行停止程序,让调用者处理,所以 : 自定义异常: 要么继承Exception要么继承RuntimeException):而针对处理的类: 就是Exception中的RuntimeException和其子类`

##### 异常处理的规则 :

`函数方法里的内容如果抛出需要检测的异常,那么函数上必须要声明,否则必须在函数内用try/catch捕捉,否则编译失败`

`如果调用到了声明异常的函数,要么try/catch,要么throws,否则编译失败`

`什么时候用catch什么时候用throws呢: 到了功能内容可以处理解决时候,用catch,解决不了或者不解决,用throws告诉调用者,由调用者解决`

`如果一个功能抛出了多个异常,那么调用的时候,必须由对应多个catch进行针对性处理`

`内部由几个需要检测的异常,就抛出几个异常(就是在我们在函数方法做业务逻辑判断时抛出的异常),抛出几个就catch`

注意 : 通常咱们没有自定义异常的对象,运行不正常跳出来的异常信息,其实是jvm默认的异常处理机制: 这个处理机制就是报异常的那个对象调用的prinStackTrance函数方法: 所显示到控制台上的信息

##### try catch finally

当try catch,没有自由需要释放,可以不用定义finally

try finall:异常无法直接catch处理,但是资源必须关闭

##### 异常的注意事项：

1. RuntimeException以及其子类如果在函数中被throw抛出，可以不用在函数上声明。
2. 子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的
  子类。
3. 如果父类抛出多个异常，那么子类只能抛出父类异常的子集。
  简单说：子类覆盖父类只能抛出父类的异常或者子类的子集。

