封装 和继承 和 多态

---

封装 : 其实是堆对象的属性实现隐藏,保证了数据的安全,只有特定的方法(get和set)可以进行设置和获取

便于使用和安全,和代码的复用

语法格式  : 在对象的属性前 : 加上private修饰符进行私有化,就可以了,不能直接访问和赋值了,

只有通过公告方法set和get对其访问和设置

private : 只是一个权限修饰符,修饰成员变量和成员函数

---

继承 

首先继承 : 通过一个关键字来完成继承的 :extend

通过这个关键字,让类与类产生了关系.

被继承的类叫父类也叫基类

继承父类的类叫子类

特点 : 

子类可以直接访问父类中非私有的属性和行为(意思就是没有用private修饰符修饰的变量和函数)

子类无法继承父类中私有的内容

继承可以多继承 (指的是直线单继承,一个类只能继承一个,父类还可以继承上一个类,多个类可以继承一个类(一个父亲多个儿子))

好处  : 提高的代码的复用性 ,同时为多态提供 了前提

注意  : 只能单继承,多继承的话会出现继承父类的方法出现相同,无法确定是那个父类中的方法



---

成员变量区别:

super : super 是父类对象的标识

this代表本类对象

当子父类中的成员变量同名用super区分父类

函数方法区别: 

成员函数  : 当子夫类中出现成员函数一模一样的情况,会运行子类的函数,子类覆盖了父类的方法,这是特性

如果想继续使用(被覆盖)父类的方法,就通过suprer.函数名获取

这个覆盖也叫重写(意思是子类重写了父类的方法)override

注意  : 父类的私有方法不可以ibei覆盖 ,父类为static的方法无法覆盖

要覆盖父类方法时 : 子类方法权限一定要大于父类方法权限

构造函数区别 : 

在子类构造函数执行时,发现父类构造函数也开始运行了?

因为 : 在子类构造函数中,其实第一行有一个默认是隐式语句:super()

注意 : 如果强调写了使用是super(有参)函数调用,是调用父类其他构造函数,而默认的父类构造函数将不会再被调用



-----

而为什么子类构造函数为什么要有super()呢?

因为子类继承了父类的属性和行为,要对属性行为使用前,要知道父类对属性和性的初始化操作

在子类构造函数中如果使用了this调用本类构造函数,那么默认的super()就没有了,因为super和this只能定义在第一行,只能有一个,但是还可以从子类的其他构造函数中访问父类的构造函数

super语句必须 : 定义在(子类构造函数的第一行),因为父类的初始化动作要先完成



----

多态: 某一类事务的多种形态

理解: 意思是动物 : 有狗有猫. 而动物的形态有很多种

具体含义 :父类对象(或者接口)的引用,指向了子类对象 格式 : 父类对象   对象名 = nue 子类对象();

提高的程序的扩展性和后期维护性

实现多态的前提是 : 必须存在继承或者实现的关系,要有覆盖重写的操作

父类引用 对象名 = new 子类对象();   这个也叫向上转型

注意重点: 编译看右,运行看左(非静态函数)   

意思是: 我们用对象名调用方法的时候,必须是子类覆盖重写的方法,想要调用子类的方法就会报classCastException的错,因为调用的方法是看父类里面的方法,在运行的时候输出的结果是子类对象里重写的函数方法的计算结果

发生不能使用子类特有的方法,我们解决的办法是向下转型

子类对象 对象名 = nue  (子类对象) 父类的引用

---

instanceof : 用于判断对象的具体类型,只能用于引用数据类型判断,通常用于向下转型的判断,如果数据类型一致,可以向下转,如果不判断,不一致数据类型向下转换,会导致报错(因为编译的时候永远看父类里面抽象方法,并且子类覆盖重写了这个方法)

---

在成员变量中 : 编译和运行都看左

意思是: 编译的时候看引用变量所属的类中是否右调用的成员变量,有就编译成功,没有就编译失败

运行,也是看引用变量所属的类中是否有调用的成员变量,重点 : (并运行该属性类的成员变量)

---

注意 : 静态函数方法的情况下,编译和运行看左

运行的时候执行是父类引用里的方法功能

---

内部类 : 

定义 : 将一个类定义在另一个类的里面,里面的类就叫内部类,(或者内置类,嵌套类)

访问特点 : 内部类可以直接访问外部类中 的成员,包括私有类,而外部类要访问内部类的成员,必须建立内部类的对象

注意 : 内部类定义在成员位置上,可以被private,static成员修饰符修饰,被static修饰的内部类只能访问外部类中的静态成员

(内部类是静态的,但是内部成员不是静态的,格式 : 外部类名.内部类名 对象名= nue 外部类名.内部类名();  此时可以访问外部静态成员了)

-----

内部类和内部成员都是静态的话,可以直接调用的,外部类名.内部类名.内部成员方法();

---

#### 匿名内部类

`就是内部类的简化手法,格式 : nue外部其他类名或者接口名(){覆盖重写nue的那个类的方法函数或者接口中的代码,(也可以自定义内容)}`然后这个匿名内部类可以直接调用nue的那个类或者接口里(抽象也可以)方法

或者赋值给类引用对象,再用那个对象去调用函数方法

`简单理解就是建立一个带内容的外部类或者接口的子类匿名对象`

---

##### 还有使用的场景:

`就是当函数方法里的参数是有个接口类型是,而且这个接口中的方法不超过三个,可以用匿名内部类作为实际参数进行传递`

